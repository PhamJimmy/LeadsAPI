var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import RealPropTypes from 'prop-types';
import { setPropTypes as setRealPropTypes, getContext as getRealContext, withContext as withRealContext } from 'recompose';

// export depending on env
var setPropTypes = void 0;
var PropTypes = void 0;
var getContext = void 0;
var withContext = void 0;

var loop = function loop(object, callback) {
    for (var i in object) {
        object.hasOwnProperty(i) && callback(i, object[i]);
    }
};

var mapArgs = function mapArgs(args) {
    if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) !== 'object') {
        return args;
    }

    var mappedArgs = args.length !== undefined ? [] : {};

    loop(args, function (key, arg) {
        if (arg && arg.ptc) {
            if (RealPropTypes[arg.type]) {
                var realArg = void 0;

                if (arg.args) {
                    realArg = RealPropTypes[arg.type].apply(RealPropTypes, _toConsumableArray(mapArgs(arg.args)));
                } else {
                    realArg = RealPropTypes[arg.type];
                }

                if (arg.required) {
                    realArg = realArg.isRequired;
                }

                mappedArgs[key] = realArg;
            } else {
                throw new Error('Unknown propType ' + arg.type);
            }
        } else {
            mappedArgs[key] = (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object' ? arg : mapArgs(arg);
        }
    });

    return mappedArgs;
};

if (process.env.NODE_ENV === 'production' && process.env.PROPER_TYPES !== 'show') {
    setPropTypes = setRealPropTypes;
    PropTypes = RealPropTypes;
    getContext = getRealContext;
    withContext = withRealContext;
} else {
    setPropTypes = function setPropTypes(properProps) {
        return function (Component) {
            var propTypes = {};
            var properTypes = {};

            loop(properProps, function (key, prop) {
                var propType = {};

                if (!prop || !prop.ptc) {
                    propTypes[key] = prop;
                    properTypes[key] = prop === null ? 'null' : typeof prop === 'undefined' ? 'undefined' : _typeof(prop);
                } else if (RealPropTypes[prop.type]) {
                    if (prop.args) {
                        propType = RealPropTypes[prop.type].apply(RealPropTypes, _toConsumableArray(mapArgs(prop.args)));
                    } else {
                        propType = RealPropTypes[prop.type];
                    }

                    if (prop.required) {
                        propType = propType.isRequired;
                    }

                    propTypes[key] = propType;
                    properTypes[key] = _extends({}, prop);
                } else {
                    throw new Error('Unknown propType ' + prop.type);
                }
            });

            Component.propTypes = _extends({}, Component.propTypes, propTypes);
            Component.properTypes = _extends({}, Component.properTypes, properTypes);

            return Component;
        };
    };

    var buildType = function buildType(type) {
        var reply = { type: type, ptc: true };
        return _extends({}, reply, { isRequired: _extends({}, reply, { required: true }) });
    };

    var buildArgType = function buildArgType(type) {
        return function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var reply = { type: type, args: args, ptc: true };
            return _extends({}, reply, { isRequired: _extends({}, reply, { required: true }) });
        };
    };

    getContext = function getContext() {
        for (var _len2 = arguments.length, context = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            context[_key2] = arguments[_key2];
        }

        return getRealContext.apply(undefined, _toConsumableArray(mapArgs(context)));
    };
    withContext = function withContext() {
        for (var _len3 = arguments.length, context = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            context[_key3] = arguments[_key3];
        }

        return withRealContext.apply(undefined, _toConsumableArray(mapArgs(context)));
    };

    // propTypes <-> properTypes mapping
    PropTypes = {
        // simple types
        any: buildType('any'),
        array: buildType('array'),
        bool: buildType('bool'),
        func: buildType('func'),
        number: buildType('number'),
        object: buildType('object'),
        string: buildType('string'),
        symbol: buildType('symbol'),
        node: buildType('node'),
        element: buildType('element'),
        // types that take args
        instanceOf: buildArgType('instanceOf'),
        oneOf: buildArgType('oneOf'),
        oneOfType: buildArgType('oneOfType'),
        arrayOf: buildArgType('arrayOf'),
        objectOf: buildArgType('objectOf'),
        shape: buildArgType('shape')
    };
}

export { setPropTypes, PropTypes, getContext, withContext };